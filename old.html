<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Physics simulation</title>
    <style>
        tr > td {
            padding-bottom: 1em;
            text-align: center;
        }
    </style>
</head>
<body>
<div>
    <canvas id="canvas" width="900" height="900" style="display: block; float: left; background-color: darkgray; border: solid black 1px">Your browser is not supported</canvas>
    <div>
        <table>
            <tbody>
            <tr>
                <td>
                    <div>
                        <label for="runBtn">Run</label><input id="runBtn" type="checkbox" checked>
                    </div>
                </td>
            </tr>
            <tr>
                <td>
                    <div>
                        <label for="gFieldBtn">G-field</label><input id="gFieldBtn" type="checkbox">
                    </div>
                </td>
            </tr>
            <tr>
                <td>
                    <div>
                        <label for="trackBtn">Track objects</label><input id="trackBtn" type="checkbox" checked>
                    </div>
                </td>
            </tr>
            <tr>
                <td>
                    <label>Steps per frame:
                        <input id="stepRangeEl" type="range" min="1" max="400" step="1" value="0" style="width: 400px"/>
                    </label>
                    <i id="stepRangeVal">0</i>
                </td>
            </tr>
            <tr>
                <td>
                    <label>Track frame:
                        <input id="trackFrameSlider" type="range" min="1" max="100" step="1" value="0" style="width: 400px"/>
                    </label>
                    <i id="trackFrameVal">0</i>
                </td>
            </tr>
            <tr>
                <td>
                    <input id="deleteRocksBtn" type="button" value="Delete rocks"/>
                </td>
            </tr>
            <tr>
                <td>
                    <label>Mass of new body:
                        <input id="createBodyMass" type="number" value="100"/>
                    </label>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
</div>
<script>
    const C = 299_792_458;
    const C2 = C * C;
    const GRAVITATIONAL_CONSTANT = 6.67430e-11;
    const PLANKS_CONSTANT = 6.62607004e-34;
    const PI = Math.PI;
    const au = 1.495978707e11


    let timePassed = 0;
    let timeScale = 60 * 60 * 24 * 1; //1 day per second
    let steps = 50; //steps per frame
    const trackLength = 3000;
    let trackFrame = 5;
    const asteroids = 0;
    let frame = 0;
    let canvas;
    let ctx;
    let cam;

    const TYPE_BLACK_HOLE = 0;
    const TYPE_STAR = 1;
    const TYPE_PLANET = 2;
    const TYPE_MOON = 3;
    const TYPE_ROCK = 4; //Rocks don't collide, nor affect each others gravitational pull
    const COLOR_BLACK = 'rgba(0, 0, 0)';
    const COLOR_STAR = 'rgb(217,217,16)';
    const COLOR_PLANET = 'rgb(84,153,15)';
    const COLOR_MOON = 'rgb(114,80,80)';
    const COLOR_ROCK = 'rgb(61,56,56)';
    const COLOR_CENTER = 'rgba(255, 0, 0)';
    const COLOR_TRACK = 'rgb(52,91,149)';
    const COLOR_PREDICTION = 'rgba(200,0,255,0.5)';
    const COLOR_NAMES = 'rgb(40,34,34)';
    // Mass in kilograms, distance in meters, velocity in m/s (ISU)
    let sun = {name: 'Sun', type: TYPE_STAR, mass: 1.989e30, radius: 696340000, x: 500, y: 0, vx: 0, vy: 0, track: []};
    let mercury = {name: 'Mercury', type: TYPE_PLANET, mass: 0.33e24, radius: 2.4395e6, x: 0, y: 5.79e10, vx: 47.4e3, vy: 0, track: []};
    let venus = {name: 'Venus', type: TYPE_PLANET, mass: 4.87e24, radius: 6052e3, x: 0, y: 1.082e11, vx: 35.0e3, vy: 0, track: []};
    let earth = {name: 'Earth', type: TYPE_PLANET, mass: 5.972e24, radius: 6371000, x: 0, y: 147.62e9, vx: 30e3, vy: 0, track: []};
    let moon = {name: 'Moon', type: TYPE_MOON, mass: 7.348e22, radius: 1737000, x: 0, y: earth.y + 3.844e8, vx: earth.vx + 1023, vy: 0, track: []};
    let mars = {name: 'Mars', type: TYPE_PLANET, mass: 0.642e24, radius: 3396e3, x: 0, y: 2.279e11, vx: 24.1e3, vy: 0, track: []};
    let jupiter = {name: 'Jupiter', type: TYPE_PLANET, mass: 1.898e27, radius: 6.991e7, x: 0, y: 7.786e11, vx: 13.1e3, vy: 0, track: []};
    let saturn = {name: 'Saturn', type: TYPE_PLANET, mass: 568e24, radius: 60268e3, x: 0, y: 1433.5e9, vx: 9.7e3, vy: 0, track: []};
    let uranus = {name: 'Uranus', type: TYPE_PLANET, mass: 86.8e24, radius: 25559e3, x: 0, y: 2872.5e9, vx: 6.8e3, vy: 0, track: []};
    let neptune = {name: 'Neptune', type: TYPE_PLANET, mass: 102.0e24, radius: 24764e3, x: 0, y: 4495.1e9, vx: 5.4e3, vy: 0, track: []};
    let pluto = {name: 'Pluto', type: TYPE_PLANET, mass: 0.0146e24, radius: 1185e3, x: 0, y: 5906.4e9, vx: 4.7e3, vy: 0, track: []};
    let bodies = [sun, earth, moon, jupiter, mercury, venus, mars, saturn, uranus, neptune, pluto];

    let lastFrameTime = 0; //last frame time in milliseconds
    let baseDt = 1.0/60; //real delta between frames in seconds
    let dt = baseDt * timeScale; //delta between frames after time scale applied
    let target; //target for camera to attach to
    let moving = false; //is pressing button
    let pausedDueToLaunch = false;
    let launchMode = false; //is launching body
    let launchStart = {x: 0, y: 0};
    let lastMousePos = {x:0, y:0} //remembering last mouse position
    let launchRelBody = null; //body relative to which launch is performed
    let simulate = true; //simulate physics. If false - nothing moves
    let drawGravity = false; //Draw gravitational field
    let drawTracks = true; //Draw tracks of big objects
    let pressedButtons = [];

    //Инициализация
    function init() {
        canvas = document.getElementById(`canvas`);
        ctx = canvas.getContext(`2d`, { alpha: false });
        ctx.font = 'bold 18px serif';

        canvas.addEventListener('wheel', function(e) {
            let zoomIn = e.wheelDelta > 0;
            let zoomMultiplier = 2;
            let oldZoom = cam.zoom;
            cam.zoom = zoomIn ? cam.zoom / zoomMultiplier : cam.zoom * zoomMultiplier;
            let mouseOnScreenFromCenter = {x: lastMousePos.x - cam.baseWidth / 2, y: lastMousePos.y - cam.baseHeight / 2}
            if (zoomIn) {
                cam.x += (mouseOnScreenFromCenter.x * oldZoom) - ((mouseOnScreenFromCenter.x * oldZoom) / zoomMultiplier);
                cam.y += (mouseOnScreenFromCenter.y * oldZoom) - ((mouseOnScreenFromCenter.y * oldZoom) / zoomMultiplier)
            } else {
                let tx = (mouseOnScreenFromCenter.x * oldZoom) * zoomMultiplier;
                let ty = (mouseOnScreenFromCenter.y * oldZoom) * zoomMultiplier;
                cam.x += (mouseOnScreenFromCenter.x * oldZoom) - tx;
                cam.y += (mouseOnScreenFromCenter.y * oldZoom) - ty;
            }
        });
        window.addEventListener('mouseup', e => {
            moving = false;
            if (launchMode && pressedButtons['Shift']) {
                let vel = getAbsoluteLaunchVelocity(launchStart, {x: e.offsetX, y: e.offsetY});
                let pos = cam.toWorldPoint(launchStart.x, launchStart.y);
                let mass = Math.max(+createBodyMass.value || 100, 1);
                let radius = Math.sqrt(mass / Math.PI) / 216410; //earth density
                let body = {name: null, type: TYPE_MOON, mass: mass, radius: radius, x: pos.x, y: pos.y, vx: vel.x, vy: vel.y, track: []};
                addBody(body);
                target = body;
            }
            launchMode = false;
            launchRelBody = null;
            if (pausedDueToLaunch) {
                pausedDueToLaunch = false;
                changeSimulate(true);
            }
        });
        canvas.addEventListener('mousedown', e => {
            let isPressingShift = pressedButtons['Shift'];
            if (isPressingShift) {
                launchMode = true;
                pausedDueToLaunch = simulate;
                changeSimulate(false);
                launchStart = {x: e.offsetX, y: e.offsetY};
                launchRelBody = target;
            } else {
                pausedDueToLaunch = false;
                moving = true;
            }
            onClick(e.offsetX, e.offsetY)
            if (isPressingShift) {
                target = null;
            }
        });
        canvas.addEventListener('mousemove', e => {
            if (moving && !target) {
                cam.x -= e.movementX * cam.zoom;
                cam.y -= e.movementY * cam.zoom;
            }
            lastMousePos.x = e.offsetX;
            lastMousePos.y = e.offsetY;
        });
        let runBtn = document.getElementById(`runBtn`);
        let gfieldBtn = document.getElementById(`gFieldBtn`);
        let trackBtn = document.getElementById(`trackBtn`);
        let deleteRocksBtn = document.getElementById(`deleteRocksBtn`);

        let changeSimulate = function (val) {
            simulate = val;
            runBtn.checked = val;
        }

        let changeGField = function (val) {
            drawGravity = val;
            gfieldBtn.checked = val;
        }

        let changeTrack = function (val) {
            drawTracks = val;
            trackBtn.checked = val;
        }

        document.addEventListener('keydown', function(e){
            if (document.activeElement && document.activeElement.tagName.toUpperCase() === 'INPUT') {
                return;
            }
            let key = e.key.toLowerCase();
            if(key === 'p' || key === 'з') {
                changeSimulate(!simulate);
            }
            if(key === 'g' || key === 'п') {
                changeGField(!drawGravity);
            }
            if(key === 't' || key === 'е') {
                changeTrack(!drawTracks);
            }
            if (key > '0' && key < '9') {
                onNumberPressed(key);
            }
            if (e.key === 'Delete' && target) {
                removeBody(target);
            }
            if (e.key === 'ArrowLeft') {
                if (target) {
                    let i = bodies.indexOf(target) - 1;
                    if (i < 0) {
                        i = bodies.length - 1;
                    }
                    target = bodies.length === 0 ? null : bodies[i];
                } else if (bodies.length > 0) {
                    target = bodies[0];
                }
            } else if (e.key === 'ArrowRight') {
                if (target) {
                    let i = bodies.indexOf(target) + 1;
                    if (i >= bodies.length) {
                        i = 0;
                    }
                    target = bodies.length === 0 ? null : bodies[i];
                } else if (bodies.length > 0) {
                    target = bodies[bodies.length - 1];
                }
            }
            pressedButtons[e.key] = true;
        })
        document.addEventListener('keyup', function(e){
            pressedButtons[e.key] = false;
        })
        let createBodyMass = document.getElementById(`createBodyMass`);
        let stepRangeEl = document.getElementById(`stepRangeEl`);
        let stepRangeVal = document.getElementById(`stepRangeVal`);
        let trackFrameSlider = document.getElementById(`trackFrameSlider`);
        let trackFrameVal = document.getElementById(`trackFrameVal`);
        stepRangeEl.value = steps;
        stepRangeVal.textContent = steps;
        trackFrameSlider.value = trackFrame;
        trackFrameVal.textContent = trackFrame;
        stepRangeEl.oninput = (e) => {
            let percent = e.target.value / e.target.max;
            steps = Math.round(Math.pow(Math.max(percent * 100, 1), 2));
            stepRangeVal.textContent = steps.toString();
        };
        trackFrameSlider.oninput = (e) => {
            trackFrame = Math.round(e.target.value)
            trackFrameVal.textContent = trackFrame.toString();
        };
        gfieldBtn.onclick = (e) => {
            changeGField(e.target.checked);
        };
        runBtn.onclick = (e) => {
            changeSimulate(e.target.checked);
        };
        trackBtn.onclick = (e) => {
            changeTrack(e.target.checked);
        };
        deleteRocksBtn.onclick = (e) => {
            let rocks = bodies.filter(b => b.type === TYPE_ROCK);
            for (const rock of rocks) {
                removeBody(rock);
            }
        };

        cam = {x: 0, y: 0, zoom: 1, baseWidth: canvas.width, baseHeight: canvas.height};
        cam.getWidth = function() {
            return this.baseWidth * this.zoom;
        };
        cam.getHeight = function() {
            return this.baseHeight * this.zoom;
        };
        cam.toCamPoint = function(x, y) {
            return {x: ((x - this.x) / this.zoom) + (this.baseWidth / 2), y: ((y - this.y) / this.zoom) + (this.baseHeight / 2)};
        }
        cam.toCamPointX = function(x) {
            return ((x - this.x) / this.zoom) + (this.baseWidth / 2);
        }
        cam.toCamPointY = function(y) {
            return ((y - this.y) / this.zoom) + (this.baseHeight / 2);
        }
        cam.toWorldPoint = function(x, y) {
            return {x: ((x - this.baseWidth / 2) * this.zoom) + this.x, y:  ((y - this.baseHeight / 2) * this.zoom) + this.y};
        }
        cam.toWorldPointV = function(v) {
            return {x: ((v.x - this.baseWidth / 2) * this.zoom) + this.x, y:  ((v.y - this.baseHeight / 2) * this.zoom) + this.y};
        }
        cam.zoom = 1e10;

        for (let i = 0; i < asteroids; i++) {
            let angle = random(0, Math.PI * 2);
            let distanceFromSun = ((mars.y + jupiter.y) / 2) + (random(-mercury.y, mercury.y)) / 1.5;
            let vel = ((mars.vx + jupiter.vx) / 2) * 0.9;
            vel = rotate(vel, 0, angle);
            let pos = rotate(0, distanceFromSun, angle);
            addBody({name: null, type: TYPE_ROCK, mass: random(1, 1e3), radius: random(1e4, 1e5), x: pos.x, y: pos.y, vx: vel.x, vy: vel.y, track: null});
        }

        for (const body of bodies) {
            if (!body.name || (body.name !== 'Moon' && body.name !== 'Earth')) {
                let angle = random(0, Math.PI * 2);
                let newPos = rotate(body.x, body.y, angle);
                let newVel = rotate(body.vx, body.vy, angle);
                body.x = newPos.x;
                body.y = newPos.y;
                body.vx = newVel.x;
                body.vy = newVel.y;
            }
        }

        bodies.sort((a, b) => b.type - a.type);

        animationFrame();
    }

    //Функция обновления. Вызывается каждый кадр
    function animationFrame() {
        let frameStartTime = window.performance.now();
        baseDt = (frameStartTime - lastFrameTime) / 1000;
        if (baseDt > 1/20) {
            baseDt = 1/60;
        }
        lastFrameTime = frameStartTime;
        dt = baseDt * timeScale;
        frame++;

        processInput();
        if (simulate) {
            let s = getActualNumberOfSteps();
            for (let i = 0; i < s; i++) {
                let stepDt = dt / s;
                updateGravitation(stepDt);
                updateBodies(stepDt);
                checkCollision();
            }
            if (frame % trackFrame === 0) {
                updateTracks();
            }
            timePassed += dt;
        }
        updateCamera();
        render();

        window.requestAnimationFrame(animationFrame);
        let frameEndTime = window.performance.now();
        fTimeHistory.push(frameEndTime - frameStartTime);
        if (fTimeHistory.length > 60) {
            avgFrameTime = 0;
            for (const fTime of fTimeHistory) {
                avgFrameTime += fTime;
            }
            avgFrameTime /= fTimeHistory.length;
            avgFrameTime /= 1000;
            fTimeHistory = [];
        }
    }

    /* since can't allow too small step size */
    function getActualNumberOfSteps() {
        const minStepSize = 1.0/1_000_000;
        const desiredStepSize = ((1 / avgFps) * timeScale) / steps;
        if (desiredStepSize > minStepSize) {
            return steps;
        } else {
            let s = Math.floor(((1 / avgFps) * timeScale) / minStepSize);
            return s < 1 ? 1 : s;
        }
    }

    function processInput() {
        let scale = 1.015;
        if (pressedButtons['Shift']) {
            scale += 0.02;
        }
        if (pressedButtons['ArrowUp']) {
            timeScale *= scale;
        } else if (pressedButtons['ArrowDown']) {
            timeScale /= scale;
        }
    }

    function updateGravitation(dt) {
        let len = bodies.length;
        for (const body of bodies) {
            body.dvx = 0;
            body.dvy = 0;
        }
        for (let i = 0; i < len; i++) {
            const a = bodies[i];
            for (let j = i + 1; j < len; j++) {
                if (a.type === TYPE_ROCK && bodies[j].type === TYPE_ROCK) continue;
                applyGravitation(a, bodies[j], dt);
            }
        }
    }

    // update body positions based on it's velocity
    function updateBodies(dt) {
        for (const body of bodies) {
            let lorentz = lorentzFactor(len(body.vx, body.vy));
            let aX = body.dvx / lorentz;
            let aY = body.dvy / lorentz;
            body.vx += aX;
            body.vy += aY;

            if (len2(body.vx, body.vy) >= C2) {
                let v = {x: body.vx, y: body.vy};
                setLen(v, C - 0.01);
                body.vx = v.x;
                body.vy = v.y;
            }

            body.x += body.vx * dt;
            body.y += body.vy * dt;
        }
    }

    function checkCollision() {
        let collidedPairs = [];
        for (let i = 0; i < bodies.length; i++) {
            let a = bodies[i];
            for (let j = i + 1; j < bodies.length; j++) {
                let b = bodies[j];
                if (a.type === TYPE_ROCK && b.type === TYPE_ROCK) continue;
                let maxRad2 = a.radius > b.radius ? a.radius * a.radius : b.radius * b.radius;
                if (len2(b.x - a.x, b.y - a.y) < maxRad2) {
                    collidedPairs.push({a: a, b: b});
                }
            }
        }
        for (const pair of collidedPairs) {
            if (!pair.a.removed && !pair.b.removed) {
                collided(pair.a, pair.b);
            }
        }
    }

    function collided(a, b) {
        let gainer = a.mass >= b.mass ? a : b;
        let destroyedBody = a.mass >= b.mass ? b : a;

        let impulse = {x: destroyedBody.vx * destroyedBody.mass, y: destroyedBody.vy * destroyedBody.mass};
        let destroyedWasTarget = destroyedBody === target;
        removeBody(destroyedBody);
        console.log(destroyedBody.name + ' (' + typeToString(destroyedBody.type) + ') was consumed by ' + gainer.name);
        gainer.vx += impulse.x / gainer.mass;
        gainer.vy += impulse.y / gainer.mass;
        let gainerArea = getCircleArea(gainer.radius);
        let destroyedArea = getCircleArea(destroyedBody.radius);
        gainer.radius = Math.sqrt((gainerArea + destroyedArea) / Math.PI);
        gainer.mass += destroyedBody.mass;
        if (destroyedWasTarget) {
            target = gainer;
        }
    }


    function updateTracks() {
        for (const body of bodies) {
            if (body.track) {
                body.track.push({x: body.x, y: body.y});
                if (body.track.length > trackLength) {
                    body.track.shift();
                }
            }
        }
    }

    function updateCamera() {
        if (target) {
            cam.x = target.x;
            cam.y = target.y;
        }
    }

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); //clear canvas
        if (drawTracks) {
            if (target && target.track && false) {
                drawRelativeTrackLines(target);
            } else {
                drawTrackLines();
            }
        }
        drawBodies();
        if (target) {
            drawForces(target);
        }
        if (launchMode) {
            drawLaunch();
        }
        if (drawGravity) {
            drawGravityField();
        }
        drawCenterOfMass();
        drawNames();
        drawStats();
    }

    let avgFps = 60;
    let avgFrameTime = 1.0/60;
    let fpsHistory = [];
    let fTimeHistory = [];
    function drawStats() {
        fpsHistory.push(1.0/baseDt);

        if (frame % 60 === 0) {
            avgFps = 0;
            for (const f of fpsHistory) {
                avgFps += f;
            }
            avgFps /= fpsHistory.length;
            fpsHistory = [];
        }
        let x = 5;
        let y = 4;
        let dy = 17;
        let actualSteps = getActualNumberOfSteps();
        let step = ((1 / avgFps) * timeScale) / actualSteps;
        let stepThrottle = actualSteps < steps? ' | ' + actualSteps : '';
        ctx.fillStyle = COLOR_BLACK
        ctx.fillText('FPS: ' + avgFps.toFixed(0) + ' / ' + ((avgFps / (1.0 / avgFrameTime)) * 100).toFixed(1) + ' %', x, y += dy);
        ctx.fillText('Time: ' + secToShortString(timePassed), x, y += dy);
        ctx.fillText('Time scale: ' + secToShortString(timeScale) + '/sec', x, y += dy);
        ctx.fillText('Step: ' + secToShortString(step) + stepThrottle, x, y += dy);
        ctx.fillText('Zoom: ' + numberToString(cam.zoom), x, y += dy);
        if (!simulate) {
            ctx.fillText('PAUSE!', x, y += dy);
        }
        if (target) {
            y += dy;
            let velocity = len(target.vx, target.vy);
            ctx.fillText('Target: ' + target.name, x, y += dy);
            ctx.fillText('  Type: ' + typeToString(target.type), x, y += dy);
            ctx.fillText('  Velocity: ' + (velocity < C / 4 ? velocity.toFixed(0) + ' m/s' : ((velocity / C) * 100).toFixed(2) + '% c'), x, y += dy);
            ctx.fillText('  Mass: ' + numberToString(target.mass), x, y += dy);
        }
        if (launchMode) {
            y += dy;
            let launchVelVec = getAbsoluteLaunchVelocity(launchStart, lastMousePos);
            let velocity = len(launchVelVec.x, launchVelVec.y);
            ctx.fillText('  Launch vel: ' + (velocity < C / 4 ? velocity.toFixed(0) + ' m/s' : ((velocity / C) * 100).toFixed(2) + '% c'), x, y += dy);
            if (launchRelBody) {
                let relativeVelVec = getLaunchVelocity(launchStart, lastMousePos);
                velocity = len(relativeVelVec.x, relativeVelVec.y);
                let distanceToRelBody = lenV(sub(cam.toWorldPointV(launchStart), launchRelBody));
                ctx.fillText('  Relative vel: ' + (velocity < C / 4 ? velocity.toFixed(0) + ' m/s' : ((velocity / C) * 100).toFixed(2) + '% c'), x, y += dy);
                velocity = getOrbitalSpeed(launchRelBody, distanceToRelBody);
                ctx.fillText('  Orbital vel: ' + (velocity < C / 4 ? velocity.toFixed(0) + ' m/s' : ((velocity / C) * 100).toFixed(2) + '% c'), x, y += dy);
            }
        }
    }
    function secToShortString(sec) {
        if (sec < 1e-3) {
            return (sec * 1e6).toFixed(0) + ' us'
        } if (sec < 1) {
            return (sec * 1e3).toFixed(0) + ' ms';
        } else if (sec < 3 * 60) {
            return sec.toFixed(0) + ' sec';
        } else if (sec < 3 * 60 * 60) {
            return (sec / 60).toFixed(0) + ' min';
        } else if (sec < 3 * 60 * 60 * 24) {
            return (sec / (60 * 60)).toFixed(1) + ' hrs';
        } else if (sec < 3 * 60 * 60 * 24 * 30.44) {
            return (sec / (60 * 60 * 24)).toFixed(1) + ' days';
        } else if (sec < 3 * 60 * 60 * 24 * 365) {
            return (sec / (60 * 60 * 24 * 30.44)).toFixed(1) + ' months';
        } else {
            return (sec / (60 * 60 * 24 * 365.24)).toFixed(1) + ' years';
        }
    }

    function numberToString(n) {
        let absN = Math.abs(n);
        if (absN < 1e-10) {
            return '0';
        }
        if (absN > 1e7) {
            return n.toExponential(2);
        }
        if (absN > 4) {
            return n.toFixed(0);
        } else if (absN > 0.1) {
            return n.toFixed(1);
        }
        let dec = 2;
        let t = absN;
        while ((t *= 10) < 1) {
            dec++;
        }
        return n.toFixed(dec);
    }

    function typeToString(type) {
        switch (type) {
            case TYPE_BLACK_HOLE: return 'Black hole';
            case TYPE_STAR: return 'Star';
            case TYPE_PLANET: return 'Planet';
            case TYPE_MOON: return 'Moon';
            case TYPE_ROCK: return 'Rock';
        }
    }

    function drawBodies() {
        ctx.lineWidth = 2;
        ctx.strokeStyle = COLOR_BLACK;
        for (const body of bodies) {
            switch (body.type) {
                case TYPE_BLACK_HOLE: ctx.fillStyle = COLOR_BLACK; break;
                case TYPE_STAR: ctx.fillStyle = COLOR_STAR; break;
                case TYPE_PLANET: ctx.fillStyle = COLOR_PLANET; break;
                case TYPE_MOON: ctx.fillStyle = COLOR_MOON; break;
                case TYPE_ROCK: ctx.fillStyle = COLOR_ROCK; break;
                default: ctx.fillStyle = COLOR_BLACK; break;
            }
            let posX = cam.toCamPointX(body.x);
            let posY = cam.toCamPointY(body.y);
            ctx.beginPath();
            ctx.arc(posX, posY, getBodyRenderWidth(body), 0, Math.PI * 2, false);
            ctx.fill();
            ctx.stroke();
        }
    }

    function getBodyRenderWidth(body) {
        let width = (body.type === TYPE_BLACK_HOLE ? getBlackHoleWidth(body.mass) : body.radius) / cam.zoom;
        let minWidth;
        switch (body.type) {
            case TYPE_BLACK_HOLE: minWidth = 6; break;
            case TYPE_STAR: minWidth = 5; break;
            case TYPE_PLANET: minWidth = 4; break;
            case TYPE_MOON: minWidth = 2; break;
            default: minWidth = 1; break;
        }
        return width > minWidth ? width : minWidth;
    }

    function getBlackHoleWidth(mass) {
        return (2 * GRAVITATIONAL_CONSTANT * mass) / C2;
    }

    function drawCenterOfMass() {
        ctx.fillStyle = COLOR_CENTER;
        ctx.beginPath();
        let centerOfMass = getCenterOfMass();
        let centerOfMassScreen = cam.toCamPoint(centerOfMass.x, centerOfMass.y);
        ctx.arc(centerOfMassScreen.x, centerOfMassScreen.y, 2, 0, Math.PI * 2, false);
        ctx.fill();
    }

    function drawLaunch() {
        if (launchRelBody) {
            drawForces(launchRelBody);
            ctx.strokeStyle = 'rgb(128,21,21)';
            let from = cam.toCamPoint(launchRelBody.x, launchRelBody.y);
            drawArrow(from, launchStart, 7);

            //drawing prediction
            if (lastMousePos.x !== launchStart.x || lastMousePos.y !== launchStart.y) {
                let predictionTime = 120; //seconds
                let predictionStep = 1/30; //step

                ctx.strokeStyle = COLOR_PREDICTION;
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);

                let startPosition = cam.toWorldPointV(launchStart);
                let vel = getLaunchVelocity(launchStart, lastMousePos);
                let tempBody = {x: startPosition.x, y: startPosition.y, vx: vel.x, vy: vel.y, mass: 1};
                for (let t = 0; t < predictionTime; t+= predictionStep) {
                    let pdt = predictionStep * timeScale; //actual step time to use
                    let fv = getGravitationalForce(tempBody, launchRelBody);

                    tempBody.vx += fv.x * pdt;
                    tempBody.vy += fv.y * pdt;
                    tempBody.x += tempBody.vx * pdt;
                    tempBody.y += tempBody.vy * pdt;
                    ctx.lineTo(cam.toCamPointX(tempBody.x), cam.toCamPointY(tempBody.y));
                }
                ctx.stroke();
            }
        }
        ctx.strokeStyle = 'rgb(0, 0, 255)';
        drawArrow(launchStart, lastMousePos);
    }

    function drawForces(body) {
        let pos = cam.toCamPoint(body.x, body.y);
        let nextSecondPos = cam.toCamPoint(body.x + body.vx * timeScale, body.y + body.vy * timeScale);
        let gravitationalPull = getGravitationalPull(body);
        let forceDest = cam.toCamPoint(body.x + (gravitationalPull.x / body.mass) * timeScale, body.y + (gravitationalPull.y / body.mass) * timeScale)
        ctx.strokeStyle = 'rgb(0, 0, 255)';
        drawArrow(pos, nextSecondPos);
        ctx.strokeStyle = 'rgb(255, 0, 0)';
        drawArrow(pos, forceDest, 7);
    }

    function getGravitationalPull(body) {
        let fX = 0;
        let fY = 0;
        for (const b of bodies) {
            if (b.type === TYPE_ROCK || b === body) {
                continue;
            }
            let f = getGravitationalForce(body, b);
            fX += f.x;
            fY += f.y;
        }
        return {x: fX, y: fY};
    }

    function drawTrackLines() {
        ctx.strokeStyle = COLOR_TRACK; //line color
        ctx.lineWidth = 1; //width of lines

        ctx.beginPath();
        for (const body of bodies) {
            let track = body.track;
            if (track && track.length > 0) {
                let movePos = cam.toCamPoint(track[0].x, track[0].y);
                ctx.moveTo(movePos.x, movePos.y);
                for (let i = 1; i < track.length; i++) {
                    let point = track[i];
                    let posX = cam.toCamPointX(point.x);
                    let posY = cam.toCamPointY(point.y);
                    ctx.lineTo(posX, posY);
                }
                if (trackFrame > 1) {
                    let pointPos = cam.toCamPoint(body.x, body.y);
                    ctx.lineTo(pointPos.x, pointPos.y);
                }
            }
        }
        ctx.stroke();
    }

    function drawRelativeTrackLines(relativeBody) {
        ctx.strokeStyle = COLOR_TRACK; //line color
        ctx.lineWidth = 1; //width of lines

        let relTrack = relativeBody.track;
        if (!relTrack || relTrack.length === 0) return;

        ctx.beginPath();
        for (const body of bodies) {
            let track = body.track;
            let minLen = Math.min(relTrack.length)
            for (let i = 0; i < minLen; i++) {
                let movePos = cam.toCamPoint(track[0].x - relTrack[0].x + relativeBody.x, track[0].y - relTrack[0].y + relativeBody.y);

                ctx.moveTo(movePos.x, movePos.y);
                for (let i = 1; i < track.length; i++) {
                    let point = track[i];
                    let posX = cam.toCamPointX(point.x - relTrack[i].x + relativeBody.x);
                    let posY = cam.toCamPointY(point.y - relTrack[i].y + relativeBody.y);
                    ctx.lineTo(posX, posY);
                }
            }
        }
        ctx.stroke();
    }

    function drawGravityField() {
        ctx.strokeStyle = 'rgb(200, 50, 50, 0.8)';
        ctx.lineWidth = 1;
        const gap = 15;
        const wingLen = gap / 7;
        for (let x = 0; x < canvas.width; x+= gap) {
            for (let y = 0; y < canvas.height; y+= gap) {
                let start = {x: x, y: y};
                let point = cam.toWorldPoint(x, y);
                let force = getGravitationalForceAtPoint(point.x, point.y);
                force.x /= cam.zoom;
                force.y /= cam.zoom;
                setLen(force, gap / 2);
                force.x += start.x;
                force.y += start.y;
                drawArrow(start, force, wingLen);
            }
        }
    }

    function drawArrow(from, to, wingLen) {
        wingLen = wingLen ? wingLen : 10;
        let a = angle(to.x - from.x, to.y - from.y);
        let rightWing = rotate(-wingLen, wingLen, a);
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.lineTo(to.x + rightWing.x, to.y + rightWing.y);
        let leftWing = rotate(rightWing.x, rightWing.y, 90 / (180 / Math.PI));
        ctx.moveTo(to.x, to.y);
        ctx.lineTo(to.x + leftWing.x, to.y + leftWing.y);
        ctx.stroke();
    }

    function drawNames() {
        ctx.fillStyle = COLOR_NAMES;
        for (const body of bodies) {
            if (body.name) {
                if (body.type <= TYPE_STAR || cam.zoom < 5e10) {
                    let pos = cam.toCamPoint(body.x, body.y);
                    ctx.fillText(body.name, pos.x, body.type === TYPE_MOON ? pos.y : pos.y - 15);
                }
            }
        }
    }

    //Рассчитывает и применяет гравитацию двух тел
    function applyGravitation(a, b, dt) {
        let dist2 = len2(b.x - a.x, b.y - a.y);
        let dist = Math.sqrt(dist2);
        let f = (GRAVITATIONAL_CONSTANT * a.mass * b.mass) / (dist2);
        let fx = ((b.x - a.x) / dist) * f * dt;
        let fy = ((b.y - a.y) / dist) * f * dt;
        /*
        a.vx += fx / a.mass;
        a.vy += fy / a.mass;
        b.vx -= fx / b.mass;
        b.vy -= fy / b.mass;
        */

        //let lorA = lorentzFactor(len(a.vx, a.vy));
        //let lorB = lorentzFactor(len(b.vx, b.vy));
        a.dvx += fx / a.mass;
        a.dvy += fy / a.mass;
        b.dvx -= fx / b.mass;
        b.dvy -= fy / b.mass;
    }

    // vector from body a to body b
    function getGravitationalForce(a, b) {
        let dist2 = len2(b.x - a.x, b.y - a.y);
        let dist = Math.sqrt(dist2);
        let f = (GRAVITATIONAL_CONSTANT * a.mass * b.mass) / (dist2);
        return {x: ((b.x - a.x) / dist) * f, y: ((b.y - a.y) / dist) * f};
    }

    // vector from body a to body b
    function getGravitationalForceAtPoint(x, y) {
        let fX = 0;
        let fY = 0;
        for (const b of bodies) {
            if (b.type !== TYPE_ROCK) {
                let dist2 = len2(b.x - x, b.y - y);
                let dist = Math.sqrt(dist2);
                let f = (GRAVITATIONAL_CONSTANT * b.mass) / (dist2);
                fX += ((b.x - x) / dist) * f;
                fY += ((b.y - y) / dist) * f;
            }
        }
        return {x: fX, y: fY};
    }

    function removeBody(body) {
        let pos = bodies.indexOf(body);
        if (pos >= 0) {
            bodies.splice(pos, 1);
            if (target === body) {
                target = null;
            }
            body.removed = true;
            return true;
        }
        return false;
    }

    function rotate(x, y, rad) {
        let cos = Math.cos(rad);
        let sin = Math.sin(rad);

        return {
            x: x * cos - y * sin,
            y: x * sin + y * cos
        };
    }

    function onClick(x, y) {
        let worldPos = cam.toWorldPoint(x, y);
        target = getBodyAt(worldPos.x, worldPos.y);
    }

    function getCenterOfMass() {
        let M = 0;
        let sumMX = 0;
        let sumMY = 0;
        for (const body of bodies) {
            if (body.type === TYPE_ROCK) continue;
            M += body.mass;
            sumMX += body.mass * body.x;
            sumMY += body.mass * body.y;
        }
        return {x: sumMX / M, y: sumMY / M};
    }

    //uses screen coordinates. Does not count relative body
    function getLaunchVelocity(from, to) {
        let v = {x: (to.x - from.x) * cam.zoom / timeScale, y: (to.y - from.y) * cam.zoom / timeScale};
        if (len2(v.x, v.y) > C2) {
            setLen(v, 0.99 * C);
        }
        return v;
    }

    //uses screen coordinates
    function getAbsoluteLaunchVelocity(from, to) {
        let v = {x: (to.x - from.x) * cam.zoom / timeScale, y: (to.y - from.y) * cam.zoom / timeScale};
        v.x += launchRelBody ? launchRelBody.vx : 0;
        v.y += launchRelBody ? launchRelBody.vy : 0;
        if (len2(v.x, v.y) > C2) {
            setLen(v, 0.99 * C);
        }
        return v;
    }

    function getOrbitalSpeed(body, distanceFromCenter) {
        return Math.sqrt((GRAVITATIONAL_CONSTANT * body.mass) / distanceFromCenter)
    }

    function onNumberPressed(n) {
        let pos = cam.toWorldPoint(lastMousePos.x, lastMousePos.y);
        let body;
        switch (n) {
            case '1': body = {name: 'marble', type: TYPE_MOON, mass: 0.01, radius: 0.01, x: pos.x, y: pos.y, vx: 0, vy: 0, track: []}; break;
            case '2': body = {name: 'person', type: TYPE_MOON, mass: 70, radius: 2, x: pos.x, y: pos.y, vx: 0, vy: 0, track: []}; break;
            case '3': body = {name: 'moon_x', type: TYPE_MOON, mass: moon.mass, radius: moon.radius, x: pos.x, y: pos.y, vx: 0, vy: 0, track: []}; break;
            case '4': body = {name: 'sun_x', type: TYPE_STAR, mass: sun.mass, radius: sun.radius, x: pos.x, y: pos.y, vx: 0, vy: 0, track: []}; break;
            case '5': body = {name: 'Black hole', type: TYPE_BLACK_HOLE, mass: sun.mass * 4e6, radius: sun.radius /*11.8e9*/, x: pos.x, y: pos.y, vx: 0, vy: 0, track: []}; break;
            case '6': body = {name: 'Rock', type: TYPE_MOON, mass: 1e4, radius: 5e3, x: pos.x, y: pos.y, vx: 0, vy: C * 0.8, track: []}; break;
        }
        if (body) {
            addBody(body, true);
        }
    }

    function addBody(b, setAsTarget) {
        bodies.push(b);
        if (setAsTarget) {
            target = b;
        }
        if (b.track && trackLength > 0) {
            b.track.push({x: b.x, y: b.y});
        }
        checkCollision();
    }

    function getBodyAt(x, y) {
        for (let i = bodies.length - 1; i >= 0; i--) {
            let b = bodies[i];
            if (len(x - b.x, y - b.y) < getBodyRenderWidth(b) * cam.zoom) {
                return b;
            }
        }
        return null;
    }

    function random(start, end) {
        return Math.random() * (end - start) + start;
    }

    function len(x, y) {
        return Math.sqrt(x * x + y * y);
    }

    function lenV(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
    }

    function sub(v1, v2) {
        return {x: v1.x - v2.x, y: v1.y - v2.y};
    }

    function sum(v1, v2) {
        return {x: v1.x + v2.x, y: v1.y + v2.y};
    }

    function setLen(v, l) {
        let cl = len(v.x, v.y);
        let multiplier = l / cl;
        v.x *= multiplier;
        v.y *= multiplier;
    }

    function len2(x, y) {
        return x * x + y * y;
    }

    function angle(x, y) {
        return Math.atan2(y, x);
    }

    function getCircleArea(r) {
        return Math.PI * r * r;
    }

    function lorentzFactor(vel) {
        return lorentzFactor2(vel * vel);
    }

    function lorentzFactor2(vel2) {
        return vel2 >= C2 ? Infinity : 1 / Math.sqrt(1 - (vel2 / C2));
    }

    function getRelativisticMass(body) {
        return lorentzFactor2(len2(body.vx, body.vy)) * body.mass;
    }

    function reverseImpulse(p, m) {
        return (C * p) / Math.sqrt(C2 * m * m + p * p);
    }

    function vel(body) {
        return len(body.vx, body.vy);
    }

    function dst(a, b) {
        return len(b.x - a.x, b.y - a.y);
    }

    init();


    function random(start, end) {
        return Math.random() * (end - start) + start;
    }

    function getCircleArea(r) {
        return Math.PI * r * r;
    }
</script>
</body>
</html>